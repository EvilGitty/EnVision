#ifndef SPECIL_INTERFACE_H
#define SPECIL_INTERFACE_H

#include <string>
#include <vector>

// Minimum Header
struct t_SpecHead
{
	std::string filename;				//	Filename des Bildes (fuer type=2)
	int type;							//	Type des Bildes
										//		type = 0   - undefiniert
										//		type = 1   - cube geladen
										//		type = 2   - cube nicht geladen
										//			(auf Festplatte halten,
										//			wegen Speicherplatz)
	void * imgcube;						//	Datacube (fuer type=1)
	std::string ID;						//	ENVI Feld unter description: ID 
	std::string wavelenunit;			// 
	std::vector <float> wavelen;		//	Wellenlaengen
	std::vector <float> exposureTimeUS;	//	Belichtung
	unsigned int headsize;				//	header size der eingelesenen Datei
	int outheadsize;					//	Headergroesse der mit write() geschreibenen Dateien
	unsigned int numdim;				//	Anzahl der Dimensionen
	unsigned long long imgsize[3];		//	Bildgroesse:
										//	 Achtung! Diese Anordnung ist jedoch keine Aussage,
										//	 wie die Daten im Speicher liegen! -> interleave
										//		Profile: RAW und C-Workflow 
										//			[0] - spatial (samples) (x)
										//			[1] - spectral	(bands)	(z)
										//			[2] - frame (lines)		(y)
	enum t_interleave {								//	interleave:
										//	 Achtung! So liegen die Daten in der Datei UND
										//	 auch im geladenen Zustand im Speicher (type = 1) ! 
		IL_UNKNOWN,						//		Unbekannt
		IL_BSQ,							//		BSQ - band sequential
		IL_BIP,							//		BIP - band interleaved by pixel
		IL_BIL							//		BIL - band interleaved by line
	} interleave;
	enum t_data_type {					//	ENVI Datentyp
		DT_UNKNOWN		=	0,			//		Unbekannt
		DT_8_BYTE		=	1,			//		1 Byte
		DT_16_SINT		=	2,			//		2 Byte Integer
		DT_32_SLONG		=	3,			//		4 Byte Integer
		DT_32_FLOAT		=	4,			//		4 Byte Float
		DT_64_DOUBLE	=	5,			//		8 Byte Float (Double)
		DT_2x32_COMPLEX	=	6,			//	2x	4 Byte Komplex	
		DT_2x64_COMPLEX	=	9,			//	2x	8 Byte Komplex
		DT_16_UINT		=	12,			//		2 Byte Unsigned Integer
		DT_32_ULONG		=	13,			//		4 Byte Unsigned Integer
		DT_64_SLONG		=	14,			//		8 Byte Integer
		DT_64_ULONG		=	15			//		8 Byte Unsigned Integer
	} data_type;
	std::string data_type_str;			//	Den Datentyp als Namen! fuer evtl. Unterscheidungen
										//	bei z.B. Tapsansi...:
										//		byte, bool, char, uchar, short, ushort, int, uint,
										//		long, ulong, float, double
	enum{								//	Byte Order
		BO_UNKNOWN	=	-1,				//
		BO_LSF		=	0,				//		least significant byte (Little-endian)
		BO_MSF		=	1				//		most significant byte (Big-endian)
	} byte_order;
	unsigned long long pixelsize;		// Pixelgroesse in Byte
	double maxval;						//
};


// Spectral Image Loader Interface Class
class SpecIL_Interface
{
public:
	// (durch static wie eine globale Funktion zu sehen
	// und verletzt damit eigentlich nicht die Definition eines Interfaces)
	//
	// Datei oeffnen:
	//	Diese Funktion verwenden um ein Objekt zu erzeugen, das mit einer bestehenden Datei genutzt werden soll.
	//	Das Standard Profil ist immer RAW.
	// Unterstuetzte Formate:
	//	HySpex:		.img und .bin	mit BSQ, BIL, BIP
	//	Nuance:		.im3
	//	(TapSansi:	.tgd			mit BIL)
	//
	// return false if file-format is not supported
	static SpecIL_Interface* open(const char* cstr_filename);


	// Ein neues Objekt erstellen:
	// format - Welches Format das Objekt haben soll.
	// Ist relevat fuer das Speichern der Daten. Header usw....
	// Unterstuetzte Formate: HySpex
	//
	// return false if format is not supported
	static SpecIL_Interface* create(const char* format);


	// ------------------------------------------------------------------------
	// ------------------------------------------------------------------------


	// Destruktor
	virtual ~SpecIL_Interface(){};
//	virtual ~SpecIL_Interface()=0; // Geht so nicht! Warum?


	// formSpecImage
	// Das Spec Image Objekt definieren
	// Wenn ein Objekt mit creat erschaffen wurde, muss diese Methode aufgerufen werden.
	// Dem Image wird erster Speicher bereit gestellt um Pixel, Frames oder Baender zu sichern.
	// Wenn das Bild anwaechst, wird auf die Festplatte ausgelagert. -> temp Datei
	// Die Daten werde NOCH NICHT fest gespeichert! Dafuer ist die write Methode da.
	virtual int formSpecImage(	const char* filename,					// zukuenftiger Speicherort
																		// Hier wird ausgelagert. MUSS angegeben werden!
								int width,								// Bild Breite -> RAW Profile: x - imgsize[0]
								int height,								// Bild Hoehe -> RAW Profile: y - imgsize[2]
								int depth,								// Bild Tiefe -> RAW Profile: z - imgsize[1]
								t_SpecHead::t_data_type type,			// Datentyp
								t_SpecHead::t_interleave interleave)=0;	// Anordnung: bsq (Standard), (bil und bip noch nicht implementiert)

	// setOutputProfile
	// Ausgabeprofil festlegen
	//	"RAW"		- RAW (Standard, wird im Konstruktur gesetzt!)
	//	"CWorkflow"	- C-Workflow
	// (Diese Methode ist ein Automat und bestimmt, wie sich die Instanz nach aussen verhaelt.)
	virtual int setOutputProfile(std::string profile)=0;


	// setImageProperties
	// Bild/Daten-Eigenschaften setzen:
	//	Manuelles setzen von Eigenschaften, wenn diese nicht vorhaneden sind. Diese Informationen werden in den
	//	SpecHeader gespeichert.
	//	Aufloesung der Dimensionen:	
	//		width - x - Samples
	//		height - y - Frames
	//		depth - z - Bands
	//			=> Weitere Dimensionen koennten ergaenzt werden. Noch NICHT implementiert!
	//	il		- Interleave, Anordnung der Daten in der Dateil: bsq, bil, bip (siehe t_SpecHead::t_interleave)
	//	dt		- Datentyp nach ENVI Formatierung, siehe t_SpecHead::t_data_type 
	virtual int setImageProperties(int width, int height, int depth, t_SpecHead::t_interleave il, t_SpecHead::t_data_type dt)=0;


	// Eine ID setzen
	// Kameraname oder aehnliches
	virtual int setID(const char* id)=0;


	// lesen der Datei und des Headers, ggf. zusätzlich aus einer extra Header Datei
	virtual int read()=0;


	// Pointer auf den Header
	virtual t_SpecHead* getHeaderPointer()=0;


	// schreiben
	virtual int write(std::string outfile)=0;


	// Profil: RAW
	//	Definition des ImgCubes:
	//
	//		     /\ z = imgsize[1] => spectral (bands)
	//		     /
	//		    /
	//		   /
	//	    0 .--------------> x = imgsize[0] => spatial (samples)
	//		  |
	//		  |
	//		  |
	//		  |
	//		  V y = imgsize[2] => frame (lines)


	// Profil: C-Workflow
	//	Definition des ImgCubes:
	//
	//		     /\ z = imgsize[1] => spectral (bands)
	//		     /
	//		    /
	//		   /
	//	    0 .--------------> y = imgsize[2] => frame (lines)
	//		  |
	//		  |
	//		  |
	//		  |
	//		  V x = imgsize[0] => spatial (samples)


	// ------------------------------------------------------------------------


	// Ebene anfordern
	// Speicher muss bereitgestellt sein!
	// -> Speicherverwaltung obligt dem Anwender!!!!
	// Es sind nur positive Koordinaten zulaessig!
	// Mit eine Koordinate = -1 wird die gewuenschte Ebenenrichtung angegeben, Bsp:
	// Fuer die z-Richtung und damit x-y Ebene: x=-1 und y=-1
	// Mit z wird dann die Ebene in z-Richtung gewaehlt
	// void* plane muss extern freigegeben werden! SpecIL macht das nicht!
	//
	// Ausgegeben Koordinatensysteme:
	// Profil RAW
		// Ebene: Band
		// 0 .--------------> x = imgsize[0] => spatial (samples)
		//	 |
		//	 |
		//	 |
		//	 |
		//   V y = imgsize[2] => frame (lines)
	// Profil C-Workflow
		// Ebene: Band
		// 0 .--------------> y = imgsize[2] => frame (lines)
		//	 |
		//	 |
		//	 |
		//	 |
		//   V x = imgsize[0] => spatial (samples)
	// Profil RAW und C-Workflow
		// Ebene: Frame
		// 0 .--------------> x = imgsize[0] => spatial (samples)
		//	 |
		//	 |
		//	 |
		//	 |
		//   V z = imgsize[1] => spectral (bands)
		// Ebene: Samples
		// 0 .--------------> z = imgsize[1] => spectral (bands)
		//	 |
		//	 |
		//	 |
		//	 |
		//   V y = imgsize[2] => frame (lines)
	virtual int getPlane(void* plane, int x, int y, int z)=0;


	// Vektor anfordern
	// Speicher muss bereitgestellt sein!
	// -> Speicherverwaltung obligt dem Anwender!!!!
	// Es sind nur positive Koordinaten zulaessig!
	// Mit eine Koordinate = -1 wird die gewuenschte Vektorrichtung angegeben, Bsp:
	// Fuer einen Vektor in z-Richtung wird z=-1 gesetzt
	// x und y bestimmen dann den Vektor
	virtual int getVector(void* vector, int x, int y, int z)=0;


	// Punkt anfordern
	// Speicher muss bereitgestellt sein!
	// -> Speicherverwaltung obligt dem Anwender!!!!
	// Mit alles drei Variablen wird die Koordinate im Bildraum angegeben
	virtual int getPoint(void* point, int x, int y, int z)=0;


	// ------------------------------------------------------------------------


	// Ebene ueberschreiben
	virtual int setPlane(void* plane, int x, int y, int z)=0;










};
#endif // SPECIL_INTERFACE_H