#include "SpecIL_Base.h"

SpecIL_Base::~SpecIL_Base()
{
	delete[] this->SpecHeader.imgcube;
	this->SpecHeader.imgcube = NULL;

	// Profilkopie
	this->SpecHaederProfile.imgcube = NULL;
};
//
SpecIL_Base::SpecIL_Base()
{
	this->init();
};
//
t_SpecHead* SpecIL_Base::getHeaderPointer()
{
	if(OutputProfile == 0)
	{
		return &SpecHeader;
	};

	if(OutputProfile == 1)
	{
		return &SpecHaederProfile;
	};
};
//
void SpecIL_Base::ErrorMsgLog(std::string errmsg)
{
	//Logdatei
	std::string file = this->SpecHeader.filename;

	size_t len = file.find_last_of(".");

	std::string logfile = file.substr(0, len);

	logfile = logfile + "_SpecIL_ERROR_LOG" + ".txt";

	std::fstream fsError(logfile, std::fstream::out | std::fstream::app);

	fsError << errmsg << std::endl;

	fsError.close();

	// Anwendungsbsp:
	// this->ErrorMsgLog(std::string("HALLOLOOL"));
};
//
int SpecIL_Base::init()
{
	this->cubemaxsize = 1000000000; // ~1GB


	// FLAGs
	this->FileDataLoaded = 0;
	this->FileHeaderLoaded = 0;
	this->OutputProfile = 0;
	this->ManualImageProperties = 0;
	this->ImageReadWriteType = 0;

	// Data Info
	this->SpecHeader.type = 0;
	this->SpecHeader.imgcube = NULL;
	this->SpecHeader.headsize = 0;
	this->SpecHeader.outheadsize = -1;
	this->SpecHeader.numdim = 3;
	this->SpecHeader.imgsize[0] = 0;
	this->SpecHeader.imgsize[1] = 0;
	this->SpecHeader.imgsize[2] = 0;
	this->SpecHeader.interleave = t_SpecHead::IL_UNKNOWN;
	this->SpecHeader.data_type = t_SpecHead::DT_UNKNOWN;
	this->SpecHeader.byte_order = t_SpecHead::BO_UNKNOWN;
	this->SpecHeader.pixelsize = 0;
	this->SpecHeader.maxval = 0;

	this->SpecHeader.ID = "HySpex";

	// Header kopieren fuer die Profilkopie:
	this->SpecHaederProfile = this->SpecHeader;

	return 0;
};
//
int SpecIL_Base::formSpecImage(const char* filename, int width, int height, int depth, t_SpecHead::t_data_type type, t_SpecHead::t_interleave interleave)
{
	// FLAG setzen, das es sich um eine zu beschreibende 
	this->ImageReadWriteType = 1;

	// Speicherort fuer die temporaeren Daten, kann auch als zukuenfitger Speicherort genutzt werden.
	// Wird gebraucht um bei großen Daten eine moegliche temporaere Datei zu erzeugen!
	this->FileTempData = std::string(filename) + ".temp"; // in wirte() wird die temp geloescht, falls dann noch vorhanden

	// Dimensionen nach RAW Profile!
	this->SpecHeader.imgsize[0] = width;	// x
	this->SpecHeader.imgsize[1] = depth;	// z
	this->SpecHeader.imgsize[2] = height;	// y
	
	
	// Anordnung
	this->SpecHeader.interleave = interleave;	
	// Datentyp
	this->SpecHeader.data_type = type;
	if(this->SpecHeader.data_type == t_SpecHead::DT_8_BYTE)
	{
		this->SpecHeader.pixelsize = 1;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_16_SINT || this->SpecHeader.data_type == t_SpecHead::DT_16_UINT )
	{
		this->SpecHeader.pixelsize = 2;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_32_SLONG || this->SpecHeader.data_type == t_SpecHead::DT_32_FLOAT || this->SpecHeader.data_type == t_SpecHead::DT_32_ULONG)
	{
		this->SpecHeader.pixelsize = 4;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_64_DOUBLE || this->SpecHeader.data_type == t_SpecHead::DT_2x32_COMPLEX || this->SpecHeader.data_type == t_SpecHead::DT_64_SLONG || this->SpecHeader.data_type == t_SpecHead::DT_64_ULONG)
	{
		this->SpecHeader.pixelsize = 8;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_2x64_COMPLEX)
	{
		this->SpecHeader.pixelsize = 16;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_UNKNOWN)
	{
		this->SpecHeader.pixelsize = 0;
	};


	this->SpecHeader.type = 2;// Speicher zum Arbeiten im RAM nicht vorhanden -> es wird immer gleich auf die HDD geschrieben

	// Speicher bereitstellen
	// Wenn schon Daten im Speicher -> Von einer Datei geladen -> Duerfen nicht ueberschrieben werden!
	if(this->SpecHeader.imgcube == 0)
	{
		double d_cubesize = this->SpecHeader.imgsize[0]*this->SpecHeader.imgsize[1]*this->SpecHeader.imgsize[2]*this->SpecHeader.pixelsize * 0.1;

		if(d_cubesize < (this->cubemaxsize/5) )
		{
			int cubesize = (int) d_cubesize;
			try{
				this->SpecHeader.imgcube = new char[cubesize];
				// Speicher zum Arbeiten im RAM vorhanden
				this->UseWriteBuffer = 1;
				this->SpecHeader.type = 1;
			}
			catch(const std::bad_alloc&)
			{
				std::string errstr;
				errstr = "In SpecIL_Base::formSpecImage(): ";
				errstr += cubesize;
				errstr += "MB -> std::bad_alloc";
				this->ErrorMsgLog(std::string(errstr));
			//	return -1;	// trotzdem weiter arbeiten... dann aber direkt auf HDD
			};
		};
	};


	// Header kopieren fuer die Profilkopie:
	this->SpecHaederProfile = this->SpecHeader;
	return 0;
};
//
int SpecIL_Base::setID(const char* id)
{
	this->SpecHeader.ID = std::string(id);

	return 0;
};
//
int SpecIL_Base::setOutputProfile(std::string profile)
{
	// resetten...
	this->SpecHaederProfile = this->SpecHeader;
	this->OutputProfile = 0;

	// Startzustand: RAW Profil

	if(profile.compare("CWorkflow") == 0)
	{
		this->OutputProfile = 1;
		this->SpecHaederProfile = this->SpecHeader;
		return 0;
	};
	//Err
	this->ErrorMsgLog("In SpecIL_Base::setOutputProfile(): invalid string parameter in profile");
	return -1;
};
//
int SpecIL_Base::setImageProperties(int width, int height, int depth, t_SpecHead::t_interleave il, t_SpecHead::t_data_type dt)
{
	this->SpecHeader.interleave = il;
	this->SpecHeader.data_type = dt;
	this->SpecHeader.imgsize[0] = width;
	this->SpecHeader.imgsize[1] = depth;
	this->SpecHeader.imgsize[2] = height;


	if(this->SpecHeader.data_type == t_SpecHead::DT_8_BYTE)
	{
		this->SpecHeader.pixelsize = 1;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_16_SINT || this->SpecHeader.data_type == t_SpecHead::DT_16_UINT )
	{
		this->SpecHeader.pixelsize = 2;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_32_SLONG || this->SpecHeader.data_type == t_SpecHead::DT_32_FLOAT || this->SpecHeader.data_type == t_SpecHead::DT_32_ULONG)
	{
		this->SpecHeader.pixelsize = 4;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_64_DOUBLE || this->SpecHeader.data_type == t_SpecHead::DT_2x32_COMPLEX || this->SpecHeader.data_type == t_SpecHead::DT_64_SLONG || this->SpecHeader.data_type == t_SpecHead::DT_64_ULONG)
	{
		this->SpecHeader.pixelsize = 8;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_2x64_COMPLEX)
	{
		this->SpecHeader.pixelsize = 16;
	};

	if(this->SpecHeader.data_type == t_SpecHead::DT_UNKNOWN)
	{
		this->SpecHeader.pixelsize = 0;
	};

	this->ManualImageProperties = 1;

	// Wenn ein Profil schon gesetzt wurde, soll es natuerlich erhalten bleiben
	if (this->OutputProfile != 0)
	{
		if(this->OutputProfile == 1)
		{
			this->setOutputProfile("CWorkflow");
		};
	};

	return 0;
};
//
int SpecIL_Base::readENVIhdr()
{
	int posFileExt = this->SpecHeader.filename.find_last_of(".") + 1;
	if(posFileExt != this->SpecHeader.filename.npos)
	{
		std::string fileExt = this->SpecHeader.filename.substr(posFileExt);

		// Ueberpruefen ob gueltige Endung
//		if(fileExt == "img" || fileExt == "bin" || fileExt == "im3")
		if(fileExt == "img" || fileExt == "bin")
		{
			std::string hdrstring = this->SpecHeader.filename;
			hdrstring.replace(posFileExt, 3, "hdr");

			// ENVI Header oeffnen
			std::ifstream ifs(hdrstring);
			if(ifs.fail() == 0)
			{
				std::string a, b, c;
				char eq = NULL;
				int inum;

				std::string line;
				while(std::getline(ifs, line))
				{
					if (line.find(" ID") == 0)
					{
						unsigned int pos_eq = line.find_first_of("=");
						std::string stID = line.substr(pos_eq+2);
						this->SpecHeader.ID = stID;
					};

					if (line.find("interleave") == 0)
					{
						std::stringstream ss(line);
						ss >> a >> eq >> b;
						if(this->ManualImageProperties == 0)
						{
							if(b.compare(std::string("bil")) == 0 ){
								this->SpecHeader.interleave = t_SpecHead::IL_BIL;
							};
							if(b.compare(std::string("bsq")) == 0 ){
								this->SpecHeader.interleave = t_SpecHead::IL_BSQ;
							};
							if(b.compare(std::string("bip")) == 0 ){
								this->SpecHeader.interleave = t_SpecHead::IL_BIP;
							};
							if(b.size() == 0){
								this->SpecHeader.interleave = t_SpecHead::IL_UNKNOWN;
							};
						};
						eq = NULL;
						a.clear();
						b.clear();
					};

					if (line.find("data type") == 0)
					{
						std::stringstream ss(line);
						ss >> a >> b >> eq >> inum;
						if(this->ManualImageProperties == 0)
						{
							switch (inum)
							{
							case 1:
								this->SpecHeader.data_type = t_SpecHead::DT_8_BYTE;
								this->SpecHeader.pixelsize = 1;
								break;
							case 2:
								this->SpecHeader.data_type = t_SpecHead::DT_16_SINT;
								this->SpecHeader.pixelsize = 2;
								break;
							case 3:
								this->SpecHeader.data_type = t_SpecHead::DT_32_SLONG;
								this->SpecHeader.pixelsize = 4;
								break;
							case 4:
								this->SpecHeader.data_type = t_SpecHead::DT_32_FLOAT;
								this->SpecHeader.pixelsize = 4;
								break;
							case 5:
								this->SpecHeader.data_type = t_SpecHead::DT_64_DOUBLE;
								this->SpecHeader.pixelsize = 8;
								break;
							case 6:
								this->SpecHeader.data_type = t_SpecHead::DT_2x32_COMPLEX;
								this->SpecHeader.pixelsize = 8;
								break;
							case 9:
								this->SpecHeader.data_type = t_SpecHead::DT_2x64_COMPLEX;
								this->SpecHeader.pixelsize = 16;
								break;
							case 12:
								this->SpecHeader.data_type = t_SpecHead::DT_16_UINT;
								this->SpecHeader.pixelsize = 2;
								break;
							case 13:
								this->SpecHeader.data_type = t_SpecHead::DT_32_ULONG;
								this->SpecHeader.pixelsize = 4;
								break;
							case 14:
								this->SpecHeader.data_type = t_SpecHead::DT_64_SLONG;
								this->SpecHeader.pixelsize = 8;
								break;
							case 15:
								this->SpecHeader.data_type = t_SpecHead::DT_64_ULONG;
								this->SpecHeader.pixelsize = 8;
								break;
							default:
								this->SpecHeader.data_type = t_SpecHead::DT_UNKNOWN;
								this->SpecHeader.pixelsize = 0;
							};
						};
						inum = 0;
						eq = NULL;
						a.clear();
						b.clear();
					};

					if (line.find("byte order") == 0)
					{
						std::stringstream ss(line);
						ss >> a >> b >> eq >> inum;

						switch (inum)
						{
						case 0:
							this->SpecHeader.byte_order = t_SpecHead::BO_LSF;
							break;
						case 1:
							this->SpecHeader.byte_order = t_SpecHead::BO_MSF;
							break;
						default:
							this->SpecHeader.byte_order = t_SpecHead::BO_UNKNOWN;
						};
						inum = 0;
						eq = NULL;
						a.clear();
						b.clear();
					};

					if (line.find("header offset") == 0)
					{
						std::stringstream ss(line);
						ss >> a >> b >> eq >> inum;

						this->SpecHeader.headsize = (unsigned int) inum;

						inum = 0;
						eq = NULL;
						a.clear();
						b.clear();
					};

					if (line.find("samples") == 0)
					{
						std::stringstream ss(line);
						ss >> a >> eq >> inum;
						if(this->ManualImageProperties == 0)
						{
							this->SpecHeader.imgsize[0] = (unsigned long long) inum;
						};

						inum = 0;
						eq = NULL;
						a.clear();
					};

					if (line.find("lines") == 0)
					{
						std::stringstream ss(line);
						ss >> a >> eq >> inum;
						if(this->ManualImageProperties == 0)
						{
							this->SpecHeader.imgsize[2] = (unsigned long long) inum;
						};
						inum = 0;
						eq = NULL;
						a.clear();
					};

					if (line.find("bands") == 0)
					{
						std::stringstream ss(line);
						ss >> a >> eq >> inum;
						if(this->ManualImageProperties == 0)
						{
							this->SpecHeader.imgsize[1] = (unsigned long long) inum;
						};

						inum = 0;
						eq = NULL;
						a.clear();
					};

					if (line.find("wavelength units") == 0)
					{
						std::stringstream ss(line);
						ss >> a >> b >> eq >> c;

						this->SpecHeader.wavelenunit = c;

						inum = 0;
						eq = NULL;
						a.clear();
						b.clear();
						c.clear();
					};

					if (line.find("wavelength") == 0)
					{
						std::string wavelengths = line.substr(line.find_last_of("=")+1);

						std::string buf;
						buf.clear();

						// stehen schon Wellenlaengen in der Struktur??
						if(this->SpecHeader.wavelen.size()==0)
						{
							for (size_t i=0; i<wavelengths.size(); ++i)
							{
								if (wavelengths[i]=='{' || wavelengths[i]==' ' || wavelengths[i]==',' || wavelengths[i]=='}' || i==wavelengths.size()-1)
								{
									if (buf.size()>0)
									{
										this->SpecHeader.wavelen.push_back((float)atof(buf.c_str()));
										buf.clear();
									};
								}
								else
								{
									buf.push_back(wavelengths[i]);
								};
							};
						};
					};

				};

				// Datei schliessen
				ifs.close();
				return 0;
			};
		};
	};

	// Err
	this->ErrorMsgLog("In SpecIL_Base::readENVIhdr(): Cant open .hdr");
	return -1;
};
//
int SpecIL_Base::writeENVIhdr(std::string outhdrfile)
{
	std::fstream fsENVIhdroutfile;
	fsENVIhdroutfile.open(outhdrfile, std::fstream::out|std::fstream::binary);

	if(fsENVIhdroutfile.fail() == false)
	{
		if(this->SpecHeader.outheadsize > -1)
		{
			fsENVIhdroutfile << "ENVI" << std::endl;
			fsENVIhdroutfile << "description = { " << std::endl;
			if(this->SpecHeader.ID.size() > 0)
			{
				fsENVIhdroutfile << " ID = " << this->SpecHeader.ID;
			};
			fsENVIhdroutfile << " }" << std::endl;
		
			fsENVIhdroutfile << "samples = " << this->SpecHeader.imgsize[0] << std::endl;
			fsENVIhdroutfile << "lines = " << this->SpecHeader.imgsize[2] << std::endl;
			fsENVIhdroutfile << "bands = " << this->SpecHeader.imgsize[1] << std::endl;
			fsENVIhdroutfile << "header offset = " << this->SpecHeader.outheadsize << std::endl;
			fsENVIhdroutfile << "data type = " << (int)this->SpecHeader.data_type << std::endl;
		
			if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
			{
				fsENVIhdroutfile << "interleave = bsq" << std::endl;
			};
			if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
			{
				fsENVIhdroutfile << "interleave = bip" << std::endl;
			};
			if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
			{
				fsENVIhdroutfile << "interleave = bil" << std::endl;
			};
			if(this->SpecHeader.interleave == t_SpecHead::IL_UNKNOWN)
			{
				fsENVIhdroutfile << "interleave = unknown" << std::endl;
			};
		
			if(this->SpecHeader.byte_order != t_SpecHead::BO_UNKNOWN)
			{
				fsENVIhdroutfile << "byte order = " << (int)this->SpecHeader.byte_order << std::endl;
			};
		
			if(this->SpecHeader.wavelen.size() > 0)
			{
				fsENVIhdroutfile << "wavelength units = nm" << std::endl;
				fsENVIhdroutfile << "wavelength  = {";
				for(unsigned int k=0; k<this->SpecHeader.wavelen.size(); k++)
				{
					fsENVIhdroutfile << this->SpecHeader.wavelen[k];
					if (k<this->SpecHeader.wavelen.size()-1)
					{
						fsENVIhdroutfile << ", ";
					};
				};
				fsENVIhdroutfile << "}" << std::endl;
			};

			fsENVIhdroutfile.close();
			return 0;
		}
		else
		{
			//Err
			this->ErrorMsgLog("In SpecIL_Base::writeENVIhdr(): No Headersize is given! First writing the datafile, then the .hdr!");
			return -1;
		};
	};

	this->ErrorMsgLog("In SpecIL_Base::writeENVIhdr(): Error write ENIV .hdr file!");
	return -1;
};
//
int SpecIL_Base::writeDataToHySpexFile(std::string outHySpexFile)
{
	std::string outfile = outHySpexFile;

	std::fstream fsDataOutfile;
	fsDataOutfile.open(outfile, std::fstream::out | std::fstream::binary);
	unsigned int outheadsize = 0;

	char buffer8[8] = {'H', 'Y', 'S', 'P', 'E', 'X', 0x00, 0x00};
	fsDataOutfile.write(buffer8, 8);
	outheadsize = outheadsize + 8;

	// Headergroesse
	char* outheadsizebuffer4 = reinterpret_cast<char*>(&outheadsize);
	fsDataOutfile.write(outheadsizebuffer4, 4);
	outheadsize = outheadsize + 4;

	// Dummy
	char dummybuffer[1949];
	fsDataOutfile.write(dummybuffer, 1949);
	outheadsize = outheadsize + 1949;

	// Baender
	unsigned int bands = (unsigned int) this->SpecHeader.imgsize[1];
	char* bufferbands = reinterpret_cast<char*>(&bands);
	fsDataOutfile.write(bufferbands,4);
	outheadsize = outheadsize + 4;

	// spatial
	unsigned int spatial = (unsigned int) this->SpecHeader.imgsize[0];
	char* bufferspatial = reinterpret_cast<char*>(&spatial);
	fsDataOutfile.write(bufferspatial,4);
	outheadsize = outheadsize + 4;

	// Dummy
	char dummy2buffer[4*26];
	fsDataOutfile.write(dummy2buffer,4*26);
	outheadsize = outheadsize + 4*26;

	// Frames
	unsigned int frames = (unsigned int) this->SpecHeader.imgsize[2];
	char* bufferframes = reinterpret_cast<char*>(&frames);
	fsDataOutfile.write(bufferframes,4);
	outheadsize = outheadsize + 4;

	if(this->SpecHeader.wavelen.size() > 0)
	{
		// Dummy
		char dummy3buffer[104];
		fsDataOutfile.write(dummy3buffer,104);
		outheadsize = outheadsize + 104;
	
		// Wellenlaengen
		for(int i = 0; i < this->SpecHeader.wavelen.size(); i++)
		{
			double value = (double) this->SpecHeader.wavelen.at(i);
			char* valbuffer = reinterpret_cast<char*>(&value);
			fsDataOutfile.write(valbuffer,8);
			outheadsize = outheadsize + 8;
		};
	};

	// Endgueltige Headergroesse schreiben
	unsigned long outpos = fsDataOutfile.tellp();
	fsDataOutfile.seekp(8);
	fsDataOutfile.write(outheadsizebuffer4, 4);
	fsDataOutfile.seekp(outpos);
	this->SpecHeader.outheadsize = (int)outheadsize;	// Fuer die .hdr

	// Bilddaten schreiben
	unsigned long long imgsize = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1] * this->SpecHeader.imgsize[2] * this->SpecHeader.pixelsize;
	if(SpecHeader.type == 1)
	{
		fsDataOutfile.write(static_cast<char*>(this->SpecHeader.imgcube), imgsize);
	};
	if(SpecHeader.type == 2)
	{
		// Das ist hier noch nicht schoen geloest....

		std::ifstream ifs(this->SpecHeader.filename.c_str(), std::ifstream::in | std::ifstream::binary);
		char* buffer = new char[1];
		ifs.seekg(this->SpecHeader.headsize, ifs.beg);
		for(long long i = 0; i < imgsize; i++)
		{
			ifs.read(buffer,1);
			fsDataOutfile.write(buffer, 1);
		};
		delete[] buffer;
		ifs.close();
	};
	
	fsDataOutfile.close();

	return 0;
};
//
int SpecIL_Base::writeDataToTGDfile(std::string outTGDfile)
{
	std::fstream fsDataOutfile;
	fsDataOutfile.open(outTGDfile, std::fstream::out | std::fstream::binary);

	char magic[4] = {'T', 'G', 'D', '!'};
	fsDataOutfile.write(magic, 4);

	unsigned int numdim = this->SpecHeader.numdim;
	char* numdim4 = reinterpret_cast<char*>(&numdim);
	fsDataOutfile.write(numdim4, 4);

	unsigned int numspatial = this->SpecHeader.imgsize[0];
	char* numspatial4 = reinterpret_cast<char*>(&numspatial);
	fsDataOutfile.write(numspatial4, 4);

	unsigned int numspectral = this->SpecHeader.imgsize[1];
	char* numspectral4 = reinterpret_cast<char*>(&numspectral);
	fsDataOutfile.write(numspectral4, 4);

	unsigned int numframe = this->SpecHeader.imgsize[2];
	char* numframe4 = reinterpret_cast<char*>(&numframe);
	fsDataOutfile.write(numframe4, 4);

	char dummy[4] = {0x00, 0x00, 0x00, 0x00};
	fsDataOutfile.write(dummy, 4);

	this->SpecHeader.outheadsize = 4 + 4 + 4*numdim + 4;

	// Bilddaten schreiben
	size_t imgsize = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1] * this->SpecHeader.imgsize[2] * this->SpecHeader.pixelsize;
	fsDataOutfile.write(static_cast<char*>(this->SpecHeader.imgcube), imgsize);
	fsDataOutfile.close();

	return 0;
};
//
// Ebenen:
int SpecIL_Base::getPlane(void* plane, int x, int y, int z)
{
	// wurde read() ausgefuehrt ?
	if(this->SpecHeader.type == 0)
	{
		// Err
		this->ErrorMsgLog("In SpecIL_Base::getPlane(): SpecHeader.type == 0, Data was not readed! Run read()!");
		return -1;
	};
	// Ein Band ausgeben
	if(x < 0 && y < 0 && z < this->SpecHaederProfile.imgsize[1])
	{
		// RAW
		if(this->OutputProfile == 0)
		{
			this->getPlane_RAW_Band(plane, x, y, z);
			return 0;
		};
		// C-Workflow
		if(this->OutputProfile == 1)
		{
			this->getPlane_CWF_Band(plane, x, y, z);
			return 0;
		};
	};
	// Einen Frame ausgeben
	if(x < 0 && z < 0 && y < this->SpecHaederProfile.imgsize[2])
	{
		// RAW und C-Workflow
		if(this->OutputProfile == 0 || this->OutputProfile == 1)
		{
			this->getPlane_RAW_Frame(plane, x, y, z);
			return 0;
		};
	};
	// Ein Samplebild ausgeben
	if(y < 0 && z < 0 && x < this->SpecHaederProfile.imgsize[0])
	{
		// RAW und C-Workflow
		if(this->OutputProfile == 0 || this->OutputProfile == 1)
		{
			this->getPlane_RAW_Sample(plane, x, y, z);
			return 0;
		};
	};
	//Err
	this->ErrorMsgLog("In SpecIL_Base::getPlane(): invalid parameters");
	return -1;
};
//
int SpecIL_Base::setPlane(void* plane, int x, int y, int z)
{
	if(this->SpecHeader.data_type == t_SpecHead::t_data_type::DT_UNKNOWN)
	{
		// Err
		this->ErrorMsgLog("In SpecIL_Base::setPlane(): SpecHeader.data_type == DT_UNKNOWN");
		return -1;
	};

	// Ein Band setzen
	if(x < 0 && y < 0)
	{
		// RAW
		if(this->OutputProfile == 0)
		{
			this->setPlane_RAW_Band(plane, x, y, z);

			return 0;
		};
		// C-Workflow
		if(this->OutputProfile == 1)
		{
//			this->setPlane_CWF_Band(plane, x, y, z);
			return 0;
		};
	};


	// Err
	this->ErrorMsgLog("In SpecIL_Base::setPlane(): invalid parameters");
	return -1;
};
//
int SpecIL_Base::getPlane_RAW_Band(void* plane, int x, int y, int z)
{
	char* BandImgbuff = static_cast<char*>(plane);
	// Daten vollstaendig im Speicher
	if(this->SpecHeader.type == 1)
	{
		char* Cubebuff = static_cast<char*>(this->SpecHeader.imgcube);
		// band interleaved by line
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			unsigned long long linesize = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0];
			// Bild zusammenbauen und umsortieren auf vereinbartes Standardformat
			for(unsigned long long j = 0; j < this->SpecHeader.imgsize[2]; j++) //y
			{
				unsigned long long cubeoff = ( (this->SpecHeader.imgsize[1] * j + (unsigned long long)z) * this->SpecHeader.imgsize[0]) * this->SpecHeader.pixelsize;
				unsigned long long bandoff = linesize * j;
				// Kopieren
				std::memmove(&BandImgbuff[bandoff], &Cubebuff[cubeoff], linesize);
			};
			return 0;
		};
		// band sequential
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			unsigned long long bandsize = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[2];
			unsigned long long cubeoff = (unsigned long long)z * bandsize;
			std::memmove(BandImgbuff, &Cubebuff[cubeoff], bandsize);
			return 0;
		};
		// band interleaved by pixel
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			for(unsigned long long j = 0; j < this->SpecHeader.imgsize[2]; j++) //y
			{
				for(unsigned long long i = 0; i < this->SpecHeader.imgsize[0]; i++) //x
				{
					unsigned long long cubeoff = ((unsigned long long)z + (i + j * this->SpecHeader.imgsize[0]) * this->SpecHeader.imgsize[1] )* this->SpecHeader.pixelsize;
					unsigned long long bandoff = (i + j * this->SpecHeader.imgsize[0]) *this->SpecHeader.pixelsize;
					std::memmove(&BandImgbuff[bandoff], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
				};
			};
			return 0;
		};
	};
	// Daten auf HDD
	// oder von/auf HDD arbeiten?
	if(this->SpecHeader.type == 2)
	{
		std::ifstream ifs( this->SpecHeader.filename, std::fstream::binary);
		// band interleaved by line
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			// Startposition
			unsigned long long fileoff = (unsigned long long)this->SpecHeader.headsize + this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize * (unsigned long long)z;
			// Zeilegroessegroesse
			unsigned long long linesize = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0];
			// Sprungweite zur naechsten Zeile
			unsigned long long jump = this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize * this->SpecHeader.imgsize[1];
			// Bild zusammenbauen
			for (unsigned long long i = 0; i < this->SpecHeader.imgsize[2]; i++)
			{
				ifs.seekg(fileoff);
				ifs.read(&BandImgbuff[i * linesize], linesize);
				fileoff = fileoff + jump;
			};
			ifs.close();
			return 0;
		};
		// band sequential
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			unsigned long long bandsize = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[2] * this->SpecHeader.pixelsize;
			unsigned long long startpos = (unsigned long long)this->SpecHeader.headsize + (unsigned long long)z * bandsize;
			ifs.seekg(startpos);
			ifs.read(BandImgbuff, bandsize);
			ifs.close();
			return 0;
		};
		// band interleaved by pixel
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			for(unsigned long long j = 0; j < this->SpecHeader.imgsize[2]; j++)
			{
				for(unsigned long long i = 0; i < this->SpecHeader.imgsize[0]; i++)
				{
					unsigned long long fileoff = (unsigned long long)this->SpecHeader.headsize + ((unsigned long long)z + (i + j * this->SpecHeader.imgsize[0]) * this->SpecHeader.imgsize[1] )* this->SpecHeader.pixelsize;
					unsigned long long bandoff = (i + j * this->SpecHeader.imgsize[0]) * this->SpecHeader.pixelsize;
					ifs.seekg(fileoff);
					ifs.read(&BandImgbuff[bandoff], this->SpecHeader.pixelsize);
				};
			};
			ifs.close();
			return 0;
		};
	};
	// Err
	this->ErrorMsgLog("In SpecIL_Base::getPlane_RAW_Band(): Invalid Parameter(s) !");
	return -1;
};
//
int SpecIL_Base::setPlane_RAW_Band(void* plane, int x, int y, int z)
{
/*	if(this->UseWriteBuffer == 0)
	{
		std::ostream os;
			
		os.open(this->FileTempData.c_str(), std::fstream::out|std::fstream::binary|std::fstream::app);
		long long pos = 0;
		os.seekp(pos);

		long long buffsize = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
		os.write((char) plane, buffsize);


		os.close();
		return 1;

	};
	if(this->UseWriteBuffer == 1)
	{

	};*/
	// Err
	this->ErrorMsgLog("In SpecIL_Base::setPlane_RAW_Band(): invalid parameters");
	return -1;
};
//
int SpecIL_Base::getPlane_RAW_Frame(void* plane, int x, int y, int z)
{
	char* FrameImgbuff = static_cast<char*>(plane);
	if(this->SpecHeader.type == 1)
	{
		char* Cubebuff = static_cast<char*>(this->SpecHeader.imgcube);
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			unsigned long long cubeoff = this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize * this->SpecHeader.imgsize[1] * (unsigned long long)y;
			unsigned long long framesize = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1];
			std::memmove(FrameImgbuff, &Cubebuff[cubeoff], framesize);
			return 0;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			unsigned long long framesize = this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
			unsigned long long cubeoff = (unsigned long long)y * framesize;
			unsigned long long jump = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[2] * this->SpecHeader.pixelsize;
			for(unsigned long long i = 0; i < this->SpecHeader.imgsize[1]; i++) //z
			{
				std::memmove(&FrameImgbuff[framesize*i], &Cubebuff[cubeoff], framesize);
				cubeoff = cubeoff + jump;
			};
			return 0;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			for (unsigned long long i = 0; i < this->SpecHeader.imgsize[0]; i++)		// x
			{
				for(unsigned long long k = 0; k < this->SpecHeader.imgsize[1]; k++)		// z
				{
					unsigned long long cubeoff = (k + (i + (unsigned long long)y * this->SpecHeader.imgsize[0]) * this->SpecHeader.imgsize[1]) * this->SpecHeader.pixelsize;
					unsigned long long frameoff = (i + k * this->SpecHeader.imgsize[0]) *this->SpecHeader.pixelsize;
					std::memmove(&FrameImgbuff[frameoff], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
				};
			};
			return 0;
		};
	};
	if(this->SpecHeader.type == 2)
	{
		std::ifstream ifs( this->SpecHeader.filename, std::fstream::binary);
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			unsigned long long fileoff = (unsigned long long)this->SpecHeader.headsize + this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize * this->SpecHeader.imgsize[1] * (unsigned long long)y;
			unsigned long long framesize = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1];
			ifs.seekg(fileoff);
			ifs.read(FrameImgbuff, framesize);
			ifs.close();
			return 0;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			unsigned long long framesize = this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
			unsigned long long fileoff = (unsigned long long)this->SpecHeader.headsize + (unsigned long long)y * framesize;
			unsigned long long jump = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[2] * this->SpecHeader.pixelsize;
			for(unsigned long long i = 0; i < this->SpecHeader.imgsize[1]; i++) //z
			{
				ifs.seekg(fileoff);
				ifs.read(&FrameImgbuff[framesize*i], framesize);
				fileoff = fileoff + jump;
			};
			ifs.close();
			return 0;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			for (unsigned long long i = 0; i < this->SpecHeader.imgsize[0]; i++)		// x
			{
				for(unsigned long long k = 0; k < this->SpecHeader.imgsize[1]; k++)		// z
				{
					unsigned long long fileoff = (unsigned long long)this->SpecHeader.headsize + (k + (i + (unsigned long long)y * this->SpecHeader.imgsize[0]) * this->SpecHeader.imgsize[1]) * this->SpecHeader.pixelsize;
					unsigned long long frameoff = (i + k * this->SpecHeader.imgsize[0]) *this->SpecHeader.pixelsize;
					ifs.seekg(fileoff);
					ifs.read(&FrameImgbuff[frameoff], this->SpecHeader.pixelsize);
				};
			};
			ifs.close();
			return 0;
		};
	};
	//Err
	this->ErrorMsgLog("In SpecIL_Base::getPlane_RAW_Frame(): invalid parameters");
	return -1;
};
//
int SpecIL_Base::getPlane_RAW_Sample(void* plane, int x, int y, int z)
{
	char* SampleImgbuff = static_cast<char*>(plane);
	if(this->SpecHeader.type == 1)
	{
		char* Cubebuff = static_cast<char*>(this->SpecHeader.imgcube);
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			unsigned long long cubeoff = (unsigned long long)x * this->SpecHeader.pixelsize;
			unsigned long long jump = this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
			unsigned long long maxlines = this->SpecHeader.imgsize[1] * this->SpecHeader.imgsize[2];
			for(unsigned long long i = 0; i < maxlines; i++)
			{
				std::memmove(&SampleImgbuff[i * this->SpecHeader.pixelsize], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
				cubeoff = cubeoff + jump;
			};
			return 0;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			unsigned long long sampleoff = 0;
			unsigned long long framejump = this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
			unsigned long long bandjump = this->SpecHeader.imgsize[2] * framejump;
			unsigned long long startrawoff = (unsigned long long)x * this->SpecHeader.pixelsize;
			for(unsigned long long j = 0; j < this->SpecHeader.imgsize[2]; j++)
			{
				unsigned long long cubeoff = startrawoff + j * framejump;
				for(unsigned long long i = 0; i < this->SpecHeader.imgsize[1]; i++)
				{
					std::memmove(&SampleImgbuff[sampleoff], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
					sampleoff = sampleoff + this->SpecHeader.pixelsize;
					cubeoff = cubeoff + bandjump;
				};
			};
			return 0;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{		
			for(unsigned long long k = 0; k < this->SpecHeader.imgsize[1]; k++)		//z
			{
				for(unsigned long long i = 0; i < this->SpecHeader.imgsize[2]; i++)	//y
				{
					unsigned long long cubeoff = (k + ((unsigned long long)x + i * this->SpecHeader.imgsize[0]) * this->SpecHeader.imgsize[1]) * this->SpecHeader.pixelsize;
					unsigned long long sampleoff = (k + i * this->SpecHeader.imgsize[1]) *this->SpecHeader.pixelsize;
					std::memmove(&SampleImgbuff[sampleoff], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
				};
			};
			return 0;
		};
	};
	if(this->SpecHeader.type == 2)
	{
		std::ifstream ifs( this->SpecHeader.filename, std::fstream::binary);
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			unsigned long long fileoff = (unsigned long long)this->SpecHeader.headsize + ((unsigned long long)x * this->SpecHeader.pixelsize);
			unsigned long long jump = this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
			unsigned long long maxlines = this->SpecHeader.imgsize[1] * this->SpecHeader.imgsize[2];
			for(unsigned long long i = 0; i < maxlines; i++)
			{
				ifs.seekg(fileoff);
				ifs.read(&SampleImgbuff[i * this->SpecHeader.pixelsize], this->SpecHeader.pixelsize);
				fileoff = fileoff + jump;
			};
			ifs.close();
			return 0;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			unsigned long long sampleoff = 0;
			unsigned long long framejump = this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
			unsigned long long bandjump = this->SpecHeader.imgsize[2] * framejump;
			unsigned long long startfileoff = (unsigned long long)this->SpecHeader.headsize + (unsigned long long)x * this->SpecHeader.pixelsize;
			for(unsigned long long j = 0; j < this->SpecHeader.imgsize[2]; j++)
			{
				unsigned long long fileoff = startfileoff + j * framejump;
				for(unsigned long long i = 0; i < this->SpecHeader.imgsize[1]; i++)
				{
					ifs.seekg(fileoff);
					ifs.read(&SampleImgbuff[sampleoff], this->SpecHeader.pixelsize);
					sampleoff = sampleoff + this->SpecHeader.pixelsize;
					fileoff = fileoff + bandjump;
				};
			};
			ifs.close();
			return 0;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			for(unsigned long long k = 0; k < this->SpecHeader.imgsize[1]; k++)		//z
			{
				for(unsigned long long i = 0; i < this->SpecHeader.imgsize[2]; i++)	//y
				{
					unsigned long long fileoff = (unsigned long long)this->SpecHeader.headsize + (k + ((unsigned long long)x + i * this->SpecHeader.imgsize[0]) * this->SpecHeader.imgsize[1]) * this->SpecHeader.pixelsize;
					unsigned long long sampleoff = (k + i * this->SpecHeader.imgsize[1]) *this->SpecHeader.pixelsize;
					ifs.seekg(fileoff);
					ifs.read(&SampleImgbuff[sampleoff], this->SpecHeader.pixelsize);
				};
			};
			ifs.close();
			return 0;
		};
	};
	//Err
	this->ErrorMsgLog("In SpecIL_Base::getPlane_RAW_Sample(): invalid parameters");
	return -1;
};
//
int SpecIL_Base::getPlane_CWF_Band(void* plane, int x, int y, int z)
{
	char* BandImgbuff = static_cast<char*>(plane);
	// Daten vollstaendig im Speicher
	if(this->SpecHaederProfile.type == 1)
	{
		char* Cubebuff = static_cast<char*>(this->SpecHaederProfile.imgcube);
		// band interleaved by line
		if(this->SpecHaederProfile.interleave == t_SpecHead::IL_BIL)
		{
			// Bild zusammenbauen und umsortieren auf vereinbartes Standardformat
			for(unsigned long long j = 0; j < this->SpecHaederProfile.imgsize[2]; j++) //y
			{
				for(unsigned long long i = 0; i < this->SpecHaederProfile.imgsize[0]; i++) //x
				{
					unsigned long long cubeoff = ( (this->SpecHaederProfile.imgsize[1] * j + (unsigned long long)z) * this->SpecHaederProfile.imgsize[0] + i ) * this->SpecHaederProfile.pixelsize;
					// x und y vertauschen...
					unsigned long long bandoff = (j + i * this->SpecHaederProfile.imgsize[2]) * this->SpecHaederProfile.pixelsize;
					// Kopieren
					std::memmove(&BandImgbuff[bandoff], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
				};
			};
			return 0;
		};
		// band sequential
		if(this->SpecHaederProfile.interleave == t_SpecHead::IL_BSQ)
		{
			unsigned long long Bandpos = (unsigned long long)z * this->SpecHaederProfile.imgsize[0] * this->SpecHaederProfile.imgsize[2] * this->SpecHaederProfile.pixelsize;
			// Bild zusammenbauen und umsortieren auf vereinbartes Standardformat
			for(unsigned long long j = 0; j < this->SpecHaederProfile.imgsize[2]; j++) //y
			{
				for(unsigned long long i = 0; i < this->SpecHaederProfile.imgsize[0]; i++) //x
					{
						unsigned long long cubeoff = (i + j * this->SpecHaederProfile.imgsize[0]) * this->SpecHaederProfile.pixelsize + Bandpos;
						unsigned long long bandoff = (j + i * this->SpecHaederProfile.imgsize[2]) * this->SpecHaederProfile.pixelsize;
						std::memmove(&BandImgbuff[bandoff], &Cubebuff[cubeoff], this->SpecHaederProfile.pixelsize);
					};
				};
				return 0;
			};
			// band interleaved by pixel
			if(this->SpecHaederProfile.interleave == t_SpecHead::IL_BIP)
			{
				for(unsigned long long j = 0; j < this->SpecHaederProfile.imgsize[2]; j++) //y
				{
					for(unsigned long long i = 0; i < this->SpecHaederProfile.imgsize[0]; i++) //x
					{
						unsigned long long cubeoff = ((unsigned long long)z + (i + j * this->SpecHaederProfile.imgsize[0]) * this->SpecHaederProfile.imgsize[1] )* this->SpecHaederProfile.pixelsize;
						unsigned long long bandoff = (j + i * this->SpecHaederProfile.imgsize[2]) * this->SpecHaederProfile.pixelsize;
						std::memmove(&BandImgbuff[bandoff], &Cubebuff[cubeoff], this->SpecHaederProfile.pixelsize);
					};
				};
				return 0;
			};
		};
		// Daten auf HDD
		// oder von/auf HDD arbeiten?
		if(this->SpecHaederProfile.type == 2)
		{
			std::ifstream ifs( this->SpecHaederProfile.filename, std::fstream::binary);
			// band interleaved by line
			if(this->SpecHaederProfile.interleave == t_SpecHead::IL_BIL)
			{
				// Startposition
				unsigned long long fileoff = (unsigned long long)this->SpecHaederProfile.headsize + this->SpecHaederProfile.imgsize[0] * this->SpecHaederProfile.pixelsize * (unsigned long long)z;
				// Zeilegroessegroesse
				unsigned long long linesize = this->SpecHaederProfile.pixelsize * this->SpecHaederProfile.imgsize[0];
				// Sprungweite zur naechsten Zeile
				unsigned long long jump = this->SpecHaederProfile.imgsize[0] * this->SpecHaederProfile.pixelsize * this->SpecHaederProfile.imgsize[1];
				// Buffer
				char* RAWBandImgbuff = new char[linesize * this->SpecHaederProfile.imgsize[2]];
				// Bild zusammenbauen
				for (unsigned long long i = 0; i < this->SpecHaederProfile.imgsize[2]; i++)
				{
					ifs.seekg(fileoff);
					ifs.read(&RAWBandImgbuff[i * linesize], linesize);
					fileoff = fileoff + jump;
				};
			ifs.close();
			// Bild umbauen
			for(unsigned long long j = 0; j < this->SpecHaederProfile.imgsize[2]; j++) //y
			{
				for(unsigned long long i = 0; i < this->SpecHaederProfile.imgsize[0]; i++) //x
				{
					unsigned long long rawoff = (i + j * this->SpecHaederProfile.imgsize[0]) * this->SpecHaederProfile.pixelsize;
					unsigned long long bandoff = (j + i * this->SpecHaederProfile.imgsize[2]) * this->SpecHaederProfile.pixelsize;
					std::memmove(&BandImgbuff[bandoff], &RAWBandImgbuff[rawoff], this->SpecHaederProfile.pixelsize);
				};
			};
			delete[] RAWBandImgbuff;
			return 0;
		};
		// band sequential
		if(this->SpecHaederProfile.interleave == t_SpecHead::IL_BSQ)
		{
			unsigned long long bandsize = this->SpecHaederProfile.imgsize[0] * this->SpecHaederProfile.imgsize[2] * this->SpecHaederProfile.pixelsize;
			char* RAWBandImgbuff = new char[bandsize];
			unsigned long long startpos = (unsigned long long)this->SpecHaederProfile.headsize + (unsigned long long)z * bandsize;
			ifs.seekg(startpos);
			ifs.read(RAWBandImgbuff, bandsize);
			ifs.close();
			// Bild umsortieren auf vereinbartes Standardformat
			for(unsigned long long j = 0; j < this->SpecHaederProfile.imgsize[2]; j++) //y
			{
				for(unsigned long long i = 0; i < this->SpecHaederProfile.imgsize[0]; i++) //x
				{
					unsigned long long rawoff = (i + j * this->SpecHaederProfile.imgsize[0]) * this->SpecHaederProfile.pixelsize;
					unsigned long long bandoff = (j + i * this->SpecHaederProfile.imgsize[2]) * this->SpecHaederProfile.pixelsize;
					std::memmove(&BandImgbuff[bandoff], &RAWBandImgbuff[rawoff], this->SpecHaederProfile.pixelsize);
				};
			};
			delete[] RAWBandImgbuff;
			return 0;
		};
		// band interleaved by pixel
		if(this->SpecHaederProfile.interleave == t_SpecHead::IL_BIP)
		{
			for(unsigned long long j = 0; j < this->SpecHaederProfile.imgsize[2]; j++)
			{
				for(unsigned long long i = 0; i < this->SpecHaederProfile.imgsize[0]; i++)
				{
					unsigned long long fileoff = (unsigned long long)this->SpecHaederProfile.headsize + ((unsigned long long)z + (i + j * this->SpecHaederProfile.imgsize[0]) * this->SpecHaederProfile.imgsize[1] )* this->SpecHaederProfile.pixelsize;
					unsigned long long bandoff = (j + i * this->SpecHaederProfile.imgsize[2]) * this->SpecHaederProfile.pixelsize;
					ifs.seekg(fileoff);
					ifs.read(&BandImgbuff[bandoff], this->SpecHaederProfile.pixelsize);
				};
			};
			ifs.close();
			return 0;
		};
	};
	// Err
	this->ErrorMsgLog("In SpecIL_Base::getPlane_RAW_Frame(): Invalid Parameter(s) !");
	return -1;
};
//
// Vektoren
int SpecIL_Base::getVector(void* vector, int x, int y, int z)
{
	// x - Vektor
	if(x < 0 && y < this->SpecHeader.imgsize[2] && z < this->SpecHeader.imgsize[1])
	{
		// RAW und C-Workflow
		if(this->OutputProfile == 0 || this->OutputProfile == 1)
		{
			this->getVector_RAW_X(vector, y, z);
			return 0;
		};
	};
	// y - Vektor
	if(x < this->SpecHeader.imgsize[0] && y < 0 && z < this->SpecHeader.imgsize[1])
	{
		// RAW und C-Workflow
		if(this->OutputProfile == 0 || this->OutputProfile == 1)
		{
			this->getVector_RAW_Y(vector, x, z);
			return 0;
		};
	};
	// z - Vektor
	if(x < this->SpecHeader.imgsize[0] && y < this->SpecHeader.imgsize[2] && z < 0)
	{
		// RAW und C-Workflow
		if(this->OutputProfile == 0 || this->OutputProfile == 1)
		{
			this->getVector_RAW_Z(vector, x, y);
			return 0;
		};
	};
	//Err
	this->ErrorMsgLog("In SpecIL_Base::getVector(): invalid parameters x, y, z, interleave or type");
	return -1;
};
//
int SpecIL_Base::getVector_RAW_X(void* vector, int y, int z)
{
	char* xVecbuff = static_cast< char* >(vector);
	if(this->SpecHeader.type == 1)
	{
		unsigned long long cubeoff;
		char* Cubebuff = static_cast<char*>(this->SpecHeader.imgcube);
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			cubeoff = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0] * ( (unsigned long long)z + this->SpecHeader.imgsize[1] * (unsigned long long)y );
			std::memmove(xVecbuff, &Cubebuff[cubeoff], this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0]);
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			cubeoff = (((unsigned long long)z * this->SpecHeader.imgsize[2] + (unsigned long long)y) * this->SpecHeader.imgsize[0]) * this->SpecHeader.pixelsize;
			std::memmove(xVecbuff, &Cubebuff[cubeoff], this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0]);
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			cubeoff = ((unsigned long long)z + (unsigned long long)y * this->SpecHeader.imgsize[1] * this->SpecHeader.imgsize[0]) * this->SpecHeader.pixelsize;
			unsigned long long jump = this->SpecHeader.imgsize[1] * this->SpecHeader.pixelsize;
			for(unsigned long long i = 0; i < this->SpecHeader.imgsize[0]; i++)
			{
				std::memmove(&xVecbuff[this->SpecHeader.pixelsize * i], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
				cubeoff = cubeoff + jump;
			};
		};
		return 0;
	};

	if(this->SpecHeader.type == 2)
	{
		std::ifstream ifs( this->SpecHeader.filename, std::fstream::binary);
		unsigned long long fileoff;
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0] * ( (unsigned long long)z + this->SpecHeader.imgsize[1] * (unsigned long long)y );
			ifs.seekg(fileoff);
			ifs.read(xVecbuff, this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0]);
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + (((unsigned long long)z * this->SpecHeader.imgsize[2] + (unsigned long long)y) * this->SpecHeader.imgsize[0]) * this->SpecHeader.pixelsize;
			ifs.seekg(fileoff);
			ifs.read(xVecbuff, this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0]);
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + ((unsigned long long)z + (unsigned long long)y * this->SpecHeader.imgsize[1] * this->SpecHeader.imgsize[0]) * this->SpecHeader.pixelsize;
			unsigned long long jump = this->SpecHeader.imgsize[1] * this->SpecHeader.pixelsize;
			for(unsigned long long i = 0; i < this->SpecHeader.imgsize[0]; i++)
			{
				ifs.seekg(fileoff);
				ifs.read(&xVecbuff[this->SpecHeader.pixelsize * i], this->SpecHeader.pixelsize);
				fileoff = fileoff + jump;
			};
		};
		ifs.close();
		return 0;
	};
};
//
int SpecIL_Base::getVector_RAW_Y(void* vector, int x, int z)
{
	char* yVecbuff = static_cast< char* >(vector);
	unsigned long long jump;

	if(this->SpecHeader.type == 1)
	{
		char* Cubebuff = static_cast<char*>(this->SpecHeader.imgcube);
		unsigned long long cubeoff;
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			cubeoff = this->SpecHeader.pixelsize * (this->SpecHeader.imgsize[0] * (unsigned long long)z + (unsigned long long)x);
			jump = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1];
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			cubeoff = (this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[2] * (unsigned long long)z + (unsigned long long)x) * this->SpecHeader.pixelsize;
			jump =  this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			cubeoff = (this->SpecHeader.imgsize[1] * (unsigned long long)x + (unsigned long long)z) * this->SpecHeader.pixelsize;
			jump = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1] * this->SpecHeader.pixelsize;
		};
		for(unsigned long long i = 0; i < this->SpecHeader.imgsize[2]; i++)
		{
			std::memmove(&yVecbuff[i * this->SpecHeader.pixelsize], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
			cubeoff = cubeoff + jump;
		};
		return 0;
	};

	if(this->SpecHeader.type == 2)
	{
		std::ifstream ifs( this->SpecHeader.filename, std::fstream::binary);
		unsigned long long fileoff;
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + this->SpecHeader.pixelsize * (this->SpecHeader.imgsize[0] * (unsigned long long)z + (unsigned long long)x);
			jump = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1];
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + (this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[2] * (unsigned long long)z + (unsigned long long)x) * this->SpecHeader.pixelsize;
			jump =  this->SpecHeader.imgsize[0] * this->SpecHeader.pixelsize;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + (this->SpecHeader.imgsize[1] * (unsigned long long)x + (unsigned long long)z) * this->SpecHeader.pixelsize;
			jump = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1] * this->SpecHeader.pixelsize;
		};
		for(unsigned long long i = 0; i < this->SpecHeader.imgsize[2]; i++)
		{
			ifs.seekg(fileoff);
			ifs.read(&yVecbuff[i * this->SpecHeader.pixelsize], this->SpecHeader.pixelsize);
			fileoff = fileoff + jump;
		};
		ifs.close();
		return 0;
	};
};
//
int SpecIL_Base::getVector_RAW_Z(void* vector, int x, int y)
{
	char* zVecbuff = static_cast< char* >(vector);
	unsigned long long jump;
	if(this->SpecHeader.type == 1)
	{
		char* Cubebuff = static_cast<char*>(this->SpecHeader.imgcube);
		unsigned long long cubeoff;
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			cubeoff = ( this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1] * (unsigned long long)y + (unsigned long long)x ) * this->SpecHeader.pixelsize;
			jump = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0];
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			cubeoff = ( this->SpecHeader.imgsize[0] * (unsigned long long)y + (unsigned long long)x ) * this->SpecHeader.pixelsize;
			jump = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[2] * this->SpecHeader.pixelsize;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			cubeoff = ( this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1] * (unsigned long long)y + (unsigned long long)x ) * this->SpecHeader.pixelsize;
			jump = this->SpecHeader.pixelsize;
		};
		for(unsigned long long i = 0; i < this->SpecHeader.imgsize[1]; i++)
		{
			std::memmove(&zVecbuff[i * this->SpecHeader.pixelsize], &Cubebuff[cubeoff], this->SpecHeader.pixelsize);
			cubeoff = cubeoff + jump;
		};
		return 0;
	};
	if(this->SpecHeader.type == 2)
	{
		std::ifstream ifs( this->SpecHeader.filename, std::fstream::binary);
		unsigned long long fileoff;
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + ( this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1] * (unsigned long long)y + (unsigned long long)x ) * this->SpecHeader.pixelsize;
			jump = this->SpecHeader.pixelsize * this->SpecHeader.imgsize[0];
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + ( this->SpecHeader.imgsize[0] * (unsigned long long)y + (unsigned long long)x ) * this->SpecHeader.pixelsize;
			jump = this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[2] * this->SpecHeader.pixelsize;
		};
		if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
		{
			fileoff = (unsigned long long)this->SpecHeader.headsize + ( this->SpecHeader.imgsize[0] * this->SpecHeader.imgsize[1] * (unsigned long long)y + (unsigned long long)x ) * this->SpecHeader.pixelsize;
			jump = this->SpecHeader.pixelsize;
		};
		for(unsigned long long i = 0; i < this->SpecHeader.imgsize[1]; i++)
		{
			ifs.seekg(fileoff);
			ifs.read(&zVecbuff[i * this->SpecHeader.pixelsize], this->SpecHeader.pixelsize);
			fileoff = fileoff + jump;
		};
		ifs.close();
		return 0;
	};
};
//
// Punkte
int SpecIL_Base::getPoint(void* point, int x, int y, int z)
{
	// RAW und C-Workflow
	if(this->OutputProfile == 0 || this->OutputProfile == 1)
	{
		this->getPoint_RAW(point, x, y, z);
		return 0;
	};
	//Err
	this->ErrorMsgLog("In SpecIL_Base::getPoint(): invalid parameter");
	return -1;
};
//
int SpecIL_Base::getPoint_RAW(void* point, int x, int y, int z)
{
	unsigned long long offset;
	char* Point = static_cast< char* >(point);
	if(this->SpecHeader.interleave == t_SpecHead::IL_BIL)
	{
		offset = ( this->SpecHeader.imgsize[0] * ( this->SpecHeader.imgsize[1] * (unsigned long long)y + (unsigned long long)z) + (unsigned long long)x ) * this->SpecHeader.pixelsize;
	};
	if(this->SpecHeader.interleave == t_SpecHead::IL_BSQ)
	{
		offset = ( (unsigned long long)x + ((unsigned long long)y + (unsigned long long)z * this->SpecHeader.imgsize[2]) * this->SpecHeader.imgsize[0] ) * this->SpecHeader.pixelsize;
	};
	if(this->SpecHeader.interleave == t_SpecHead::IL_BIP)
	{
		offset = ((unsigned long long)z + ((unsigned long long)x + (unsigned long long)y * this->SpecHeader.imgsize[0]) * this->SpecHeader.imgsize[1] )* this->SpecHeader.pixelsize;
	};
	if(this->SpecHeader.type == 1)
	{
		char* Cubebuff = static_cast<char*>(this->SpecHeader.imgcube);
		std::memmove(Point, &Cubebuff[offset], this->SpecHeader.pixelsize);
		return 0;
	};
	if(this->SpecHeader.type == 2)
	{
		std::ifstream ifs( this->SpecHeader.filename, std::fstream::binary);
		ifs.seekg(offset + (unsigned long long)this->SpecHeader.headsize);
		ifs.read(Point, this->SpecHeader.pixelsize);
		ifs.close();
		return 0;
	};
	//Err
	this->ErrorMsgLog("In SpecIL_Base::getPoint_RAW(): invalid parameters x, y, z, interleave or type");
	return -1;
};
// ----------------------------------------------------------------------------
// In der Entwicklung
/*
int SpecIL_Base::makeObj(int width,int height,int depth,t_SpecHead::t_data_type type,t_SpecHead::t_interleave interleave)
{
	// Dimensionen
	this->SpecHeader.imgsize[0]	= height;
	this->SpecHeader.imgsize[1]	= depth;
	this->SpecHeader.imgsize[2]	= width;

	this->SpecHeader.data_type	= type;
	this->SpecHeader.interleave	= interleave;

	if(type == t_SpecHead::DT_8_BYTE)
	{
		this->SpecHeader.pixelsize = 1;
	};
	if(type == t_SpecHead::DT_16_SINT || type == t_SpecHead::DT_16_UINT)
	{
		this->SpecHeader.pixelsize = 2;
	};
	if(type == t_SpecHead::DT_32_SLONG || type == t_SpecHead::DT_32_FLOAT || type == t_SpecHead::DT_32_ULONG)
	{
		this->SpecHeader.pixelsize = 4;
	};
	if(type == t_SpecHead::DT_64_DOUBLE || type == t_SpecHead::DT_2x32_COMPLEX || type == t_SpecHead::DT_64_SLONG || type == t_SpecHead::DT_64_ULONG)
	{
		this->SpecHeader.pixelsize = 8;
	};
	if(type == t_SpecHead::DT_2x64_COMPLEX)
	{
		this->SpecHeader.pixelsize = 16;
	};

	unsigned long long imgsize = height * depth * width * this->SpecHeader.pixelsize;

	if(imgsize < 500000000)
	{
		try
		{
			this->SpecHeader.imgcube = static_cast<void*>(	new char[imgsize]	);
		}
		catch(const std::bad_alloc&)
		{
			//Err
			this->ErrorMsgLog("In SpecIL_Base::makeObj(): bad_alloc");
			return -1;
		};
	}
	else
	{



	};

	return 0;
};
//*/
